# # Сортировка: sort, sorted
# # sort (метод)
# ages = [12, 34, 23, 55, 11, 4]  # список
# ages.sort()  # sort сам себя упорядочивает по уполчанию
# print(ages)  # но при этом список был изменен и потерял свою уникальность
# # Поэтому вариант ниже более правильный, так как сохраняет
# # исходную уникальность списка:
# ages = [12, 34, 23, 55, 11, 4]
# ages_sort = ages.copy()  # создали копию списка
# ages_sort.sort()
# print(ages)  # не изменен
# print(ages_sort)  # сортировка выполнена
# # Этот способ плох тем, что требует больше времени на выполнение. Поэтому,
# # в качестве сортировки чего-либо лучше использовать ф-цию sorted, так
# # как она выполняет все вышеописанное самостоятельно.
#
# # sorted (функция)
# ages = [12, 34, 23, 55, 11, 4]
# ages_sort = sorted(ages)
# print(ages, ages_sort)
#
# # value = ages.sort()  # пример возврата пустого значения
# # print(">>>>", value)
#
# value = "342abc51QW+=/"  # строка (неизменяемый объект)
# result = sorted(value)
# print(result)  # sorted выполнен, при этом разложив строку в список.
# # sort бы так не смог, так как метод не работает со строкой, а ф-ция - да.
# # Сортировка выполняется по таблице кодировки ASCII. Именно за счет
# # порядковых значений в ней, value будет иметь такую последовательность
# # внутри себя.
#
# print(ord("+"), ord("3"))  # через ord можно узнать п.н. символа в ASCII
# print(chr(43), chr(51))  # через chr можно узнать сам символ в ASCII
#
# # print(result[::-1])  # обратный порядок при распечатке
# # result = sorted(value)[::-1]  # обратный порядок при упорядочивании
# # но оба эти варианта реверса данных лучше заменить на:
# value = "342abc51QW+=/"
# result = sorted(value, reverse=True)  # если False, то порядок не изменится
# print(result)
#
# value = ["Name", "Age_1", "Age_Z", "Sex", "address"]
# result = sorted(value)
# print(result)  # sorted упорядочил символы в соответствии с ASCII,
# # но выглядит как стандартная иерархия латинского алфавита,
# # учитывая последовательности букв в словах. Но если заменить первый
# # символ на нижний регистр, иерархия алфавита нарушится, так как действуют
# # правила таблицы кодировки.
#
# value = ["Name", "Age_1", "Age_Z", "Sex", "address"]
# result = sorted(value, reverse=True, key=len)
# print(result)  # тут сделана сотировка по длине символов (len) через ключ
# # сортировки (key). Значала идут длинные слова, так как задали reverse.
# # По умолчанию - от меньшего к большему (по таблице кодировки).

# Практика
my_str = "blablacar"
my_symbol = "bla"
#
# # 1
# # У вас есть переменная my_str, тип - str. И переменная my_symbol, тип - str.
# # Напечатать ЧИСЛО - сколько раз my_symbol встречается в my_str.
# # Пример: my_str="blablacar", my_symbol="bla".
# # Вывод на экран:
# # 2
# count = my_str.count(my_symbol)
# print(count)
#
# # 2
# # У вас есть переменная my_str, тип - str. И переменная my_symbol, тип - str.
# # Напечатать СКОЛЬКО РАЗ my_symbol встречается в my_str.
# # Пример: my_str="blablacar", my_symbol="bla".
# # Вывод на экран:
# # bla
# # bla
# count = my_str.count(my_symbol)  # вариант 1 - через цикл
# for _ in range(count):  # _ - заглушка для неиспользуемой переменной
#     print(my_symbol)
# print("----------")  # для проверки пустых строк
# # responce = (my_symbol + "\n") * count  # вариант 2 - "топорный"
# responce = f"{my_symbol}\n" * count  # вариант 3 - через формат
# print(responce.strip())  # .strip() - отброс лишней пустой строки
# print("----------")  # для проверки пустых строк

# 3
# У вас есть переменная my_str, тип - str. Напечатать ЧИСЛО - сколько
# РАЗНЫХ символов встречается в my_str.
# Большая и маленькая буква считается как один символ.
# Пробелы, запятые и т.д. считаем тоже как символы.
# Пример: my_str_1="bla BLA car".
# Вывод на экран:
# 6
my_str_1 = "bla BLA car"
